proc gen_adapter {num} {
    if {[file exists "hdl/adapter.v"]} {
	file delete -force "hdl/adapter.v"
    }
    set fp [open "hdl/adapter.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module adapter ("
    puts $fp "    //axi lite interface "
    puts $fp "    input S_AXI_ACLK,"
    puts $fp "    input S_AXI_ARESETN,"
    puts $fp "    input \[31 : 0\] S_AXI_AWADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_AWPROT,"
    puts $fp "    input S_AXI_AWVALID,"
    puts $fp "    output S_AXI_AWREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_WDATA,"
    puts $fp "    input \[3 : 0\] S_AXI_WSTRB,"
    puts $fp "    input S_AXI_WVALID,"
    puts $fp "    output S_AXI_WREADY,"
    puts $fp "    output \[1 : 0\] S_AXI_BRESP,"
    puts $fp "    output S_AXI_BVALID,"
    puts $fp "    input S_AXI_BREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_ARADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_ARPROT,"
    puts $fp "    input S_AXI_ARVALID,"
    puts $fp "    output S_AXI_ARREADY,"
    puts $fp "    output \[31 : 0\] S_AXI_RDATA,"
    puts $fp "    output \[1 : 0\] S_AXI_RRESP,"
    puts $fp "    output S_AXI_RVALID,"
    puts $fp "    input S_AXI_RREADY,"
    puts $fp "    //acc clock"
    puts $fp "    input acc_clk,"
    puts $fp "    input acc_rstn,"
    puts $fp "    //acc interface   "
    puts $fp "    output ap_rst,"
    puts $fp "    output ap_start,"
    puts $fp "    output ap_start_single,"
    puts $fp "    input ap_idle,"
    puts $fp "    input ap_done,"
    puts $fp "    input ap_ready,"
    puts $fp "    output ap_continue,"
    puts $fp "    output ap_clk,"
    puts $fp "    //scalar interface"
    puts $fp "    output \[31:0\] scalar_write_addr,"
    puts $fp "    output \[31:0\] scalar_read_addr,"
    puts $fp "    output \[31:0\] scalar_din,"
    puts $fp "    output scalar_we,"
    puts $fp "    output scalar_re,"
    puts $fp "    input \[31:0\] scalar_dout,"
    puts $fp "    output \[C_NUM_INPUT_SCALARS-1:0\] inscalar_next,"
    puts $fp "    input \[C_NUM_INPUT_SCALARS-1:0\] inscalar_fifo_empty,"
    puts $fp "    input \[C_NUM_INPUT_SCALARS-1:0\] inscalar_fifo_full,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_fifo_empty,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_fifo_full,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_empty,"
    puts $fp "    input \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_dout,"
    puts $fp "    output \[C_NUM_OUTPUT_SCALARS-1:0\] outscalar_null_read,"
    puts $fp "    //input argument control interface"
    puts $fp "    output inbram_ctrl_allow,"
    puts $fp "    input \[C_NUM_INPUT_BRAMs-1:0\] inbram_ctrl_ready,"
    puts $fp "    input \[C_NUM_INPUT_BRAMs-1:0\] inoutbram_ctrl_ready,"
    puts $fp "    //input argument control interface"
    puts $fp "    output infifo_ctrl_allow,"
    puts $fp "    //output bram control interface"
    puts $fp "    output outbram_ctrl_allow,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_ready,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_canstart,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write,"
    puts $fp "    //output fifo control interface"
    puts $fp "    output outfifo_ctrl_allow"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "parameter C_ACC_RESET_POLARITY = 0; //active reset value (zero is active low, one is active high)"
    puts $fp "parameter C_NUM_INPUT_SCALARS = 0;"
    puts $fp "parameter C_NUM_OUTPUT_SCALARS = 0;"
    puts $fp "parameter C_QUEUE_DEPTH = 16;"
    puts $fp ""
    puts $fp "parameter C_NUM_INPUT_FIFOs = 0;"
    puts $fp "parameter C_NUM_OUTPUT_FIFOs = 0;"
    puts $fp ""
    puts $fp "parameter C_NUM_OUTPUT_BRAMs = 0;"
    puts $fp "parameter C_NUM_INPUT_BRAMs = 0;"
    puts $fp ""
    puts $fp "    localparam C_MAX = 128; //maximum quantity of scalars, fifos, brams"
    puts $fp "    "
    puts $fp "    localparam idle=0,update=1,wait_deps=2,start=3,wait_done=4;"
    puts $fp "    reg \[2:0\] ctrl_state = idle;"
    puts $fp "    "
    puts $fp "    integer idx;"
    puts $fp "    "
    puts $fp "    reg \[31:0\] slv_reg_in;"
    puts $fp "    reg slv_reg_in_vld;"
    puts $fp "    wire \[31:0\] slv_reg_out;"
    puts $fp "    wire slv_reg_out_vld;"
    puts $fp "    wire \[13:0\] slv_reg_addr;"
    puts $fp "    wire slv_reg_addr_vld;"
    puts $fp ""
    puts $fp "    wire \[C_MAX-1:0\] outscalar_fifo_empty_i;"
    puts $fp "    wire \[C_MAX-1:0\] outscalar_fifo_full_i;"
    puts $fp "    reg \[C_MAX-1:0\] outscalar_null_read_i;"
    puts $fp "    wire \[C_MAX-1:0\] inscalar_fifo_empty_i;"
    puts $fp "    wire \[C_MAX-1:0\] inscalar_fifo_full_i;"
    puts $fp "    reg \[C_MAX*32-1:0\] outbram_depth_i;"
    puts $fp "    reg \[C_MAX-1:0\] outbram_depth_write_i;"
    puts $fp "    "
    puts $fp "    reg ap_rst_i;"
    puts $fp "    "
    puts $fp "    reg start_core;         //signal to start acc core"
    puts $fp "    "
    puts $fp "    reg running_core;       //state of accelerator is running"
    puts $fp "    "
    puts $fp "    wire \[31:0\] cmd_dout;    //data out from command queue"
    puts $fp "    wire cmd_read;           //read signal to command queue"
    puts $fp "    reg cmd_write;           //write signal to command queue"
    puts $fp "    wire cmd_empty;          //empty signal from command queue"
    puts $fp "    wire cmd_full;           //full signal from command queue"
    puts $fp "    "
    puts $fp "    wire done_dout;          //data out from done queue"
    puts $fp "    reg done_read;           //read signal to done queue"
    puts $fp "    wire done_empty;         //empty signal from done queue"
    puts $fp "    wire done_full;          //full signal from done queue"
    puts $fp "    "
    puts $fp "    wire \[31:0\] control_reg;  //control register 0"
    puts $fp "    wire \[31:0\] status_reg;  //status register 1"
    puts $fp "    "
    puts $fp "    //scalar registers"
    puts $fp "    reg \[31:0\] scalar_write_addr_i;"
    puts $fp "    reg \[31:0\] scalar_read_addr_i;"
    puts $fp "    reg scalar_we_i;"
    puts $fp "    reg scalar_re_i;"
    puts $fp "    "
    puts $fp "    //accelerator assignments"
    puts $fp "    assign ap_rst = ((acc_rstn) ? (~C_ACC_RESET_POLARITY) : C_ACC_RESET_POLARITY);"
    puts $fp "    assign ap_continue = 0;"
    puts $fp "    assign ap_clk = acc_clk;"
    puts $fp "    "
    puts $fp "    //scalar assignments"
    puts $fp "    assign scalar_write_addr = scalar_write_addr_i;"
    puts $fp "    assign scalar_read_addr = scalar_read_addr_i;"
    puts $fp "    assign scalar_din = slv_reg_out;"
    puts $fp "    assign scalar_we = scalar_we_i;"
    puts $fp "    assign scalar_re = scalar_re_i;"
    puts $fp "    assign outscalar_null_read = outscalar_null_read_i;"
    puts $fp "    "
    puts $fp "    //bram assignments"
    puts $fp "    generate"
    puts $fp "       if(C_NUM_OUTPUT_BRAMs > 0) begin"
    puts $fp "	       assign outbram_depth = outbram_depth_i\[C_NUM_OUTPUT_BRAMs*32-1:0\];"
    puts $fp "	       assign outbram_depth_write = outbram_depth_write_i\[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "       end"
    puts $fp "       else begin"
    puts $fp "	       assign outbram_depth = 0;"
    puts $fp "	       assign outbram_depth_write = 0;"
    puts $fp "       end"
    puts $fp "    endgenerate"
    puts $fp "        "
    puts $fp "    //internal signal assignments"
    puts $fp "    assign control_reg\[0\] = 0;      //start reset signal - unused"
    puts $fp "    assign control_reg\[1\] = 0; //reset ongoing status - unused"
    puts $fp "    assign control_reg\[31:2\] = 0;            //unused"
    puts $fp "    "
    puts $fp "    assign status_reg\[0\] = 0;    //TDB: core running status bit"
    puts $fp "    assign status_reg\[1\] = 0;       //registered acc done bit (COR) - unimplemented"
    puts $fp "    assign status_reg\[2\] = 0;         //straight ap_idle signal - unimplemented"
    puts $fp "    assign status_reg\[3\] = 0;        //straight ap_ready signal - unimplemented"
    puts $fp "    assign status_reg\[4\] = 0;       //done full signal from queue - unimplemented (CDC)"
    puts $fp "    assign status_reg\[5\] = done_empty;      //done empty signal from queue"
    puts $fp "    assign status_reg\[6\] = done_dout;       //done data out signal from queue"
    puts $fp "    assign status_reg\[31:7\] = 0;            //unused"
    puts $fp ""
    puts $fp "    //set in/out scalar status based on number of enabled in/out scalars"
    puts $fp "    genvar i;"
    puts $fp "    generate"
    puts $fp "        if(C_NUM_OUTPUT_SCALARS == 0) begin"
    puts $fp "            assign outscalar_fifo_full_i = 0;"
    puts $fp "            assign outscalar_fifo_empty_i = 0;"
    puts $fp "        end"
    puts $fp "        "
    puts $fp "        if(C_NUM_INPUT_SCALARS == 0) begin"
    puts $fp "            assign inscalar_fifo_full_i = 0;"
    puts $fp "            assign inscalar_fifo_empty_i = 0;"
    puts $fp "        end"
    puts $fp "        "
    puts $fp "        for(i=0; i<C_NUM_OUTPUT_SCALARS; i=i+1) begin : OUTSCALAR_ASSIGN"
    puts $fp "            assign outscalar_fifo_full_i\[i\] = outscalar_fifo_full\[i\];"
    puts $fp "            assign outscalar_fifo_empty_i\[i\] = outscalar_fifo_empty\[i\];"
    puts $fp "        end"
    puts $fp "        for(i=0; i<C_NUM_INPUT_SCALARS; i=i+1) begin : INSCALAR_ASSIGN"
    puts $fp "            assign inscalar_fifo_full_i\[i\] = inscalar_fifo_full\[i\];"
    puts $fp "            assign inscalar_fifo_empty_i\[i\] = inscalar_fifo_empty\[i\];"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "            "
    puts $fp "    //write address decode, register map implementation"
    puts $fp "    always @(posedge S_AXI_ACLK) begin"
    puts $fp "       //default values"
    puts $fp "       outbram_depth_write_i <= 0;"
    puts $fp "       "
    puts $fp "        if(S_AXI_ARESETN == 0) begin"
    puts $fp "            //values to set on reset"
    puts $fp "        end"
    puts $fp "        else begin"
    puts $fp "            if(slv_reg_out_vld) begin"
    puts $fp "                case(slv_reg_addr)"
    puts $fp "                    14'd0: begin"
    puts $fp "                        //slv_reg_out\[0\];  //write 1 to bit 0 to start reset sequence - unimplemented"
    puts $fp "                        //slv_reg_out\[31:1\], read only"
    puts $fp "                    end"
    puts $fp "                    14'd1: begin"
    puts $fp "                        //slv_reg_out\[0\], read only"
    puts $fp "                        //slv_reg_out\[1\]; done clean - unused"
    puts $fp "                        //slv_reg_out\[31:2\], read only"
    puts $fp "                    end"
    puts $fp "                    //14'd2 command reg implemented in non-clocked process"
    set iscalar_num [expr $num + 2]
    puts $fp "		          //14'd${iscalar_num}-3 input scalar, implemented in non-clocked process"
    set oscalar_start [expr $iscalar_num + 1]
    set oscalar_stop [expr $oscalar_start + $num - 1]
    puts $fp "                    //14'd${oscalar_stop}-${oscalar_start} output scalar, read-only"
    set istatus_start [expr $oscalar_stop + 1]
    set istatus_stop [expr $istatus_start + $num - 1]
    puts $fp "                    //14'd${istatus_stop}-${istatus_start} input scalar status, read-only"
    set ostatus_start [expr $istatus_stop + 1]
    set ostatus_stop [expr $ostatus_start + $num - 1]
    puts $fp "                    //14'd${ostatus_stop}-${ostatus_start} output scalar status, read-only"
    set depth_start [expr $ostatus_stop + 1]
    for {set idx 0} {$idx < $num} {incr idx} {
	set depth [expr $depth_start + $idx]
	set start [expr 32 * $idx]
	set stop [expr $start + 31]
	puts $fp "                    14'd${depth}: begin  //output arg${idx} length"
	puts $fp "                        outbram_depth_i\[${stop}:${start}\] <= slv_reg_out;"
	puts $fp "                        outbram_depth_write_i\[${idx}\] <= 1;"
	puts $fp "                    end"
    }
    puts $fp "                    default: begin"
    puts $fp "                    end"
    puts $fp "                endcase"
    puts $fp "            end"
    puts $fp "        end "
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //combinational logic for scalar module write-enable (we) generation and address translation (adapter address to scalar module addressing)"
    puts $fp "    always @(*) begin"
    puts $fp "        //default values"
    puts $fp "       scalar_write_addr_i <= 0;"
    puts $fp "        scalar_we_i <= 0;"
    puts $fp "        cmd_write <= 0;"
    puts $fp "        "
    puts $fp "        if(slv_reg_out_vld) begin"
    puts $fp "            case(slv_reg_addr)"
    puts $fp "                //14'd0 control reg, implemented in clocked process"
    puts $fp "                //14'd1 status reg, implemented in clocked process"
    puts $fp "                14'd2: begin  //command reg"
    puts $fp "                    cmd_write <= 1;"
    puts $fp "                end"
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr 3 + $idx]
	puts $fp "                14'd${addr}: begin  //input scalar ${idx}"
	puts $fp "                    scalar_we_i <= 1;"
	puts $fp "                    scalar_write_addr_i <= ${idx};"
	puts $fp "                end"
    }
    puts $fp "                //14'd${oscalar_stop}-${oscalar_start} output scalar, read-only"
    puts $fp "                //14'd${istatus_stop}-${istatus_start} input scalar status, read-only"
    puts $fp "                //14'd${ostatus_stop}-${ostatus_start} output scalar status, read-only"
    set oarg_start [expr $ostatus_stop + 1]
    set oarg_stop [expr $oarg_start + $num - 1]
    puts $fp "                //14'd${oarg_stop}-${oarg_start} output argument length, implemented in clocked process"
    puts $fp "                default: begin"
    puts $fp "                end"
    puts $fp "            endcase"
    puts $fp "        end"
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //read address decode, register map implementation"
    puts $fp "    always @(*) begin"
    puts $fp "        //default values"
    puts $fp "        slv_reg_in <= 32'h5eaf000d;"
    puts $fp "        scalar_read_addr_i <= 0;"
    puts $fp "        scalar_re_i <= 0;"
    puts $fp "        outscalar_null_read_i <= 0;"
    puts $fp "        done_read <= 0;"
    puts $fp "       "
    puts $fp "        if(slv_reg_addr_vld) begin"
    puts $fp "            case(slv_reg_addr)"
    puts $fp "                14'd0: begin   //control register"
    puts $fp "                    slv_reg_in <= control_reg;"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                end"
    puts $fp "                14'd1: begin   //status register"
    puts $fp "                    slv_reg_in <= status_reg;"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                    if(~done_empty)"
    puts $fp "                        done_read <= 1;"
    puts $fp "                end"
    puts $fp "                14'd2: begin   //command register"
    puts $fp "                    slv_reg_in <= {26'd0,   //Reserved"
    puts $fp "			                 1'd0,           //bit[5] cmd_empty - unimplemented (CDC)"
    puts $fp "			                 cmd_full,    //bit\[4\]"
    puts $fp "			                 4'd0};       //bits\[3:0\] - number of elements in fifo (unimplemented)"
    puts $fp "                    slv_reg_in_vld <= 1;"
    puts $fp "                end"
    puts $fp "                //14'd${iscalar_num}-3 input scalar, write only"
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $oscalar_start + $idx]
	puts $fp "                14'd${addr}: begin  //output scalar ${idx}"
	puts $fp "                    scalar_read_addr_i <= C_MAX+${idx};"
	puts $fp "                    slv_reg_in <= scalar_dout;"
	puts $fp "                    slv_reg_in_vld <= 1;"
	puts $fp "                    scalar_re_i <= 1;"
	puts $fp "                end"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $istatus_start + $idx];
	puts $fp "                14'd${addr}: begin  //input scalar ${idx} status"
	puts $fp "                        slv_reg_in <= {26'd0,                     //Reserved"
	puts $fp "                                       inscalar_fifo_empty_i\[${idx}\], //bit\[5\] - input scalar fifo empty"
	puts $fp "                                       inscalar_fifo_full_i\[${idx}\],  //bit\[4\] - input scalar fifo full"
	puts $fp "                                       4'd0};                        //bits\[3:0\] - number of elements in fifo (unimplemented)"
	puts $fp "                        slv_reg_in_vld <= 1;"
	puts $fp "                end"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	set addr [expr $ostatus_start + $idx]
	puts $fp "                14'd${addr}: begin  //output scalar ${idx} status"
	puts $fp "                    outscalar_null_read_i\[${idx}\] <= 1;"
	puts $fp "                    slv_reg_in <= {23'd0,                       //Reserved"
	puts $fp "                                   outscalar_fifo_empty_i\[${idx}\], //bit\[8\] - output scalar fifo empty"
	puts $fp "                                   outscalar_fifo_full_i\[${idx}\],  //bit\[7\] - output scalar fifo full"
	puts $fp "                                   outscalar_null_dout\[${idx}\],    //bit\[6\] - output scalar null fifo data out"
	puts $fp "                                   outscalar_null_empty\[${idx}\],   //bit\[5\] - output scalar null fifo empty"
	puts $fp "                                   1'b0,                        //bit\[4\] - output scalar null fifo full (0)"
	puts $fp "                                   4'd0};                       //bits\[3:0\] - number of elements in fifo (unimplemented)"
	puts $fp "                    slv_reg_in_vld <= 1;"
	puts $fp "                end"
    }
    puts $fp "                default: begin"
    puts $fp "                end"
    puts $fp "            endcase"
    puts $fp "        end"
    puts $fp "    end"
    puts $fp "    "
    puts $fp "    //command register queue"
    puts $fp "    fifo #( "
    puts $fp "        .WIDTH(32),"
    puts $fp "        .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "    ) cmd_queue ("
    puts $fp "        .wr_clk(S_AXI_ACLK),"
    puts $fp "        .din(slv_reg_out),"
    puts $fp "        .write(cmd_write),"
    puts $fp "        .full(cmd_full),"
    puts $fp "        .dout(cmd_dout),"
    puts $fp "        .read(cmd_read),"
    puts $fp "        .empty(cmd_empty),"
    puts $fp "        .rd_clk(acc_clk) "
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //ap_done queue"
    puts $fp "    fifo #( "
    puts $fp "        .WIDTH(1),"
    puts $fp "        .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "    ) done_queue ("
    puts $fp "        .wr_clk(acc_clk),"
    puts $fp "        .din(1),"
    puts $fp "        .write(ap_done),"
    puts $fp "        .full(done_full),"
    puts $fp "        .dout(done_dout),"
    puts $fp "        .read(done_read),"
    puts $fp "        .empty(done_empty),"
    puts $fp "        .rd_clk(S_AXI_ACLK) "
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //command queue handler"
    puts $fp "    cmd_control #("
    puts $fp "        .NUM_INPUT_SCALARS(C_NUM_INPUT_SCALARS),"
    puts $fp "        .NUM_OUTPUT_SCALARS(C_NUM_OUTPUT_SCALARS),"
    puts $fp "        .NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    puts $fp "        .NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    puts $fp "        .NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    puts $fp "        .NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs)"
    puts $fp "    ) cmd_ctrl ("
    puts $fp "        //command queue interface"
    puts $fp "        .clk(acc_clk),"
    puts $fp "        .rstn(acc_rstn),"
    puts $fp "        .din(cmd_dout),"
    puts $fp "        .read(cmd_read),"
    puts $fp "        .empty(cmd_empty),"
    puts $fp "        .ap_start(ap_start),"
    puts $fp "        .ap_start_single(ap_start_single),"
    puts $fp "        .ap_done(ap_done),"
    puts $fp "        .ap_ready(ap_ready),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .inbram_ctrl_allow(inbram_ctrl_allow),"
    puts $fp "        .inbram_ctrl_ready(inbram_ctrl_ready),"
    puts $fp "        .inoutbram_ctrl_ready(inoutbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_allow(outbram_ctrl_allow),"
    puts $fp "        .outbram_ctrl_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_canstart(outbram_ctrl_canstart),"
    puts $fp "        .infifo_ctrl_allow(infifo_ctrl_allow),"
    puts $fp "        .outfifo_ctrl_allow(outfifo_ctrl_allow)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    //axi lite interface module"
    puts $fp "    AXI_LITE_IF #("
    puts $fp "        .C_S_AXI_DATA_WIDTH(32)"
    puts $fp "    ) axi_lite_if_i ("
    puts $fp "        .slv_reg_in(slv_reg_in),"
    puts $fp "        .slv_reg_in_vld(slv_reg_in_vld),"
    puts $fp "        .slv_reg_out(slv_reg_out),"
    puts $fp "        .slv_reg_out_vld(slv_reg_out_vld),"
    puts $fp "        .slv_reg_addr(slv_reg_addr),"
    puts $fp "        .slv_reg_addr_vld(slv_reg_addr_vld),"
    puts $fp "        .S_AXI_ACLK(S_AXI_ACLK),"
    puts $fp "        .S_AXI_ARESETN(S_AXI_ARESETN),"
    puts $fp "        .S_AXI_AWADDR(S_AXI_AWADDR),"
    puts $fp "        .S_AXI_AWPROT(S_AXI_AWPROT),"
    puts $fp "        .S_AXI_AWVALID(S_AXI_AWVALID),"
    puts $fp "        .S_AXI_AWREADY(S_AXI_AWREADY),"
    puts $fp "        .S_AXI_WDATA(S_AXI_WDATA),"
    puts $fp "        .S_AXI_WSTRB(S_AXI_WSTRB),"
    puts $fp "        .S_AXI_WVALID(S_AXI_WVALID),"
    puts $fp "        .S_AXI_WREADY(S_AXI_WREADY),"
    puts $fp "        .S_AXI_BRESP(S_AXI_BRESP),"
    puts $fp "        .S_AXI_BVALID(S_AXI_BVALID),"
    puts $fp "        .S_AXI_BREADY(S_AXI_BREADY),"
    puts $fp "        .S_AXI_ARADDR(S_AXI_ARADDR),"
    puts $fp "        .S_AXI_ARPROT(S_AXI_ARPROT),"
    puts $fp "        .S_AXI_ARVALID(S_AXI_ARVALID),"
    puts $fp "        .S_AXI_ARREADY(S_AXI_ARREADY),"
    puts $fp "        .S_AXI_RDATA(S_AXI_RDATA),"
    puts $fp "        .S_AXI_RRESP(S_AXI_RRESP),"
    puts $fp "        .S_AXI_RVALID(S_AXI_RVALID),"
    puts $fp "        .S_AXI_RREADY(S_AXI_RREADY)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "endmodule"

    close $fp
}

proc gen_scalar {num} {
    if {[file exists "hdl/scalar.v"]} {
	file delete -force "hdl/scalar.v"
    }
    set fp [open "hdl/scalar.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module scalar("
    puts $fp "    input clk,"
    puts $fp "    input acc_clk,"
    puts $fp "    //control interface"
    puts $fp "    input \[31:0\] scalar_read_addr,"
    puts $fp "    input scalar_re,"
    puts $fp "    output \[31:0\] scalar_dout,"
    puts $fp "    input scalar_we,"
    puts $fp "    input \[31:0\] scalar_write_addr,"
    puts $fp "    input \[31:0\] scalar_din,"
    puts $fp "    input outscalar_capture,"
    puts $fp "    input \[C_NUM_INSCALARS-1:0\] inscalar_next,"
    puts $fp "    output \[C_NUM_INSCALARS-1:0\] inscalar_fifo_empty,"
    puts $fp "    output \[C_NUM_INSCALARS-1:0\] inscalar_fifo_full,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_fifo_empty,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_fifo_full,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_null_empty,"
    puts $fp "    output \[C_NUM_OUTSCALARS-1:0\] outscalar_null_dout,"
    puts $fp "    input \[C_NUM_OUTSCALARS-1:0\] outscalar_null_read,"
    puts $fp "    //input scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    output \[C_INSCALAR_${idx}_BITS-1:0\] inscalar${idx},"
    }
    puts $fp "    //output scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input \[C_OUTSCALAR_${idx}_BITS-1:0\] outscalar${idx},"
    }
    puts $fp "    //output scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input outscalar${idx}_vld,"
	} else {
	    puts $fp "    input outscalar${idx}_vld"
	}
    }
    puts $fp ");"
    puts $fp ""
    puts $fp "parameter C_NUM_INSCALARS = 0;"
    puts $fp "parameter C_NUM_OUTSCALARS = 0;"
    puts $fp "parameter C_FIFO_DEPTH = 16;"
    puts $fp "parameter C_HAS_RETURN = 0;"
    puts $fp ""
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INSCALAR_${idx}_BITS = 32;"
    }
    puts $fp ""
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\]  C_OUTSCALAR_${idx}_BITS = 32;"
    }
    puts $fp ""
    puts $fp "localparam C_MAX_INSCALARS = ${num};"
    puts -nonewline $fp "localparam \[(C_MAX_INSCALARS*32)-1:0\] C_INSCALAR_BIT_ARRAY = {"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INSCALAR_${val}_BITS,"
    }
    puts $fp "C_INSCALAR_0_BITS};"
    puts $fp ""
    puts $fp "localparam C_MAX_OUTSCALARS = ${num};"
    puts -nonewline $fp "localparam \[(C_MAX_OUTSCALARS*32)-1:0\] C_OUTSCALAR_BIT_ARRAY = {";
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTSCALAR_${val}_BITS,"
    }
    puts $fp "C_OUTSCALAR_0_BITS};"
    puts $fp ""
    puts $fp "localparam C_MAX_SCALAR_BITS = 1024;"
    puts $fp ""
    puts $fp "reg \[31:0\] scalar_out_reg;  //output data register for control interface"
    puts $fp ""
    puts $fp "wire \[C_NUM_INSCALARS-1:0\] inscalar_we;                              //write enables for input scalars"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] inscalar_fifo \[0:C_NUM_INSCALARS-1\];    //input scalar data values from register to fifo"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] inscalar \[0:C_NUM_INSCALARS-1\];         //input scalar data values from fifo to ports"
    puts $fp "wire \[C_MAX_INSCALARS-1:0\] inscalar_ready;                           //input scalar ready to be buffered in fifo"
    puts $fp ""
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_re;                            //read enables for output scalars"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] outscalar \[0:C_NUM_OUTSCALARS-1\];       //output scalar data values from port into reg"
    puts $fp "reg  \[C_MAX_SCALAR_BITS-1:0\] outscalar_reg \[0:C_NUM_OUTSCALARS-1\];   //output scalar data values from reg into fifo"
    puts $fp "wire \[C_MAX_SCALAR_BITS-1:0\] outscalar_fifo \[0:C_NUM_OUTSCALARS-1\];  //output scalar data values from fifo into 32bit interface"
    puts $fp "wire \[31:0\] outscalar_fifo32 \[0:C_NUM_OUTSCALARS-1\];                 //output scalar data values from fifo 32bit chunk (for reading)"
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_vld;                           //output scalar valid signals"
    puts $fp "reg \[C_NUM_OUTSCALARS-1:0\] outscalar_found_vld;                     //output scalar valid found signals"
    puts $fp "wire \[C_NUM_OUTSCALARS-1:0\] outscalar_read;                         //read signal from the out_register to the outscalar_fifo"
    puts $fp ""
    puts $fp "reg capture_reg;//register the capture signal to trigger the next cycle"
    puts $fp ""
    puts $fp "always @(posedge acc_clk)"
    puts $fp "    capture_reg <= outscalar_capture;"
    puts $fp ""
    puts $fp "generate"
    puts $fp "    //map input scalar data values from register to ports"
    puts $fp "    if(C_NUM_INSCALARS > 0)"
    puts $fp "        assign inscalar0 = inscalar\[0\]\[C_INSCALAR_0_BITS-1:0\];"
    puts $fp "    else begin"
    puts $fp "        assign inscalar0 = 0;"
    puts $fp "        assign inscalar_fifo_empty = 0;"
    puts $fp "        assign inscalar_fifo_full = 0;"
    puts $fp "    end"
    puts $fp ""
    for {set idx 1} {$idx < $num} {incr idx} {
	puts $fp "    if(C_NUM_INSCALARS > ${idx})"
	puts $fp "        assign inscalar${idx} = inscalar\[${idx}\]\[C_INSCALAR_${idx}_BITS-1:0\];"
	puts $fp "    else"
	puts $fp "        assign inscalar${idx} = 0;"
	puts $fp ""
    }
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//map output scalar data values from ports to register"
    puts $fp "generate"
    puts $fp "    if(C_NUM_OUTSCALARS > 0) begin"
    puts $fp "        assign outscalar\[0\]\[C_OUTSCALAR_0_BITS-1:0\] = outscalar0;"
    puts $fp "        if(C_HAS_RETURN > 0)"
    puts $fp "            assign outscalar_vld\[0\] = outscalar_capture;"
    puts $fp "        else"
    puts $fp "            assign outscalar_vld\[0\] = outscalar0_vld;"
    puts $fp "    end"
    for {set idx 1} {$idx < $num} {incr idx} {
	puts $fp "    if(C_NUM_OUTSCALARS > ${idx}) begin"
	puts $fp "        assign outscalar\[${idx}\]\[C_OUTSCALAR_${idx}_BITS-1:0\] = outscalar${idx};"
	puts $fp "        assign outscalar_vld\[${idx}\] = outscalar${idx}_vld;"
	puts $fp "    end"
    }
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//assign output data reg to port"
    puts $fp "assign scalar_dout = scalar_out_reg;"
    puts $fp ""
    puts $fp "//generate input scalar registers"
    puts $fp "genvar idx;"
    puts $fp "generate"
    puts $fp "    for(idx=0; idx<C_NUM_INSCALARS; idx=idx+1) begin :INSCALAR_REG_GEN"
    puts $fp "        in_register #("
    puts $fp "            .C_NUM_BITS(C_INSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "        ) inscalar_reg ("
    puts $fp "            .din(scalar_din),"
    puts $fp "            .we(inscalar_we\[idx\]),"
    puts $fp "            .clk(clk),"
    puts $fp "            .dout(inscalar_fifo\[idx\]\[C_INSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .ready(inscalar_ready\[idx\])"
    puts $fp "        );"
    puts $fp ""
    puts $fp "        fifo #("
    puts $fp "            .WIDTH(C_INSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "            .DEPTH(C_FIFO_DEPTH)"
    puts $fp "        ) in_fifo_i ("
    puts $fp "            .wr_clk(clk),"
    puts $fp "            .din(inscalar_fifo\[idx\]\[C_INSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .write(inscalar_ready\[idx\]),"
    puts $fp "            .full(inscalar_fifo_full\[idx\]),"
    puts $fp "            .dout(inscalar\[idx\]\[C_INSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .read(inscalar_next\[idx\]),"
    puts $fp "            .empty(inscalar_fifo_empty\[idx\]),"
    puts $fp "            .rd_clk(acc_clk)"
    puts $fp "        );"
    puts $fp ""
    puts $fp "        assign inscalar_we\[idx\] = scalar_we & (scalar_write_addr == idx);"
    puts $fp "    end"
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "//generate output scalar registers"
    puts $fp "generate"
    puts $fp "    if(C_NUM_OUTSCALARS == 0) begin"
    puts $fp "        assign outscalar_fifo32\[0\] = 0;"
    puts $fp "        assign outscalar_fifo32\[-1\] = 0;"
    puts $fp ""
    puts $fp "        assign outscalar_fifo_empty = 0;"
    puts $fp "        assign outscalar_fifo_full = 0;"
    puts $fp "        assign outscalar_null_empty = 0;"
    puts $fp "        assign outscalar_null_dout = 0;"
    puts $fp "    end"
    puts $fp ""
    puts $fp "    for(idx=0; idx<C_NUM_OUTSCALARS; idx=idx+1) begin :OUTSCALAR_REG_GEN"
    puts $fp "        //generate valid latch"
    puts $fp "        always @(posedge acc_clk) begin"
    puts $fp "            if(outscalar_vld\[idx\]) begin"
    puts $fp "                outscalar_reg\[idx\]\[C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] <= outscalar\[idx\]\[C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                outscalar_found_vld\[idx\] <= 1;"
    puts $fp "            end"
    puts $fp "            if(capture_reg)"
    puts $fp "                outscalar_found_vld\[idx\] <= 0;"
    puts $fp "        end"
    puts $fp ""
    puts $fp "        fifo #("
    puts $fp "            .WIDTH(C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "            .DEPTH(C_FIFO_DEPTH)"
    puts $fp "        ) out_fifo_i ("
    puts $fp "            .wr_clk(acc_clk),"
    puts $fp "            .din(outscalar_reg\[idx\]\[C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .write(capture_reg),"
    puts $fp "            .full(outscalar_fifo_full\[idx\]),"
    puts $fp "            .dout(outscalar_fifo\[idx\]\[C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .read(outscalar_read\[idx\]),"
    puts $fp "            .empty(outscalar_fifo_empty\[idx\]),"
    puts $fp "            .rd_clk(clk)"
    puts $fp "        );"
    puts $fp ""
    puts $fp "        fifo #("
    puts $fp "            .WIDTH(1),"
    puts $fp "            .DEPTH(C_FIFO_DEPTH)"
    puts $fp "        ) null_fifo_i ("
    puts $fp "            .wr_clk(acc_clk),"
    puts $fp "            .din(outscalar_found_vld\[idx\]),"
    puts $fp "            .write(capture_reg),"
    puts $fp "            //.full(outscalar_fifo_full\[idx\]),"
    puts $fp "            .dout(outscalar_null_dout\[idx\]),"
    puts $fp "            .read(outscalar_null_read\[idx\]),"
    puts $fp "            .empty(outscalar_null_empty\[idx\]),"
    puts $fp "            .rd_clk(clk) "
    puts $fp "        );"
    puts $fp ""
    puts $fp "        out_register #("
    puts $fp "            .C_NUM_BITS(C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "        ) outscalar_reg_i ("
    puts $fp "            .din(outscalar_fifo\[idx\]\[C_OUTSCALAR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "            .read(outscalar_read\[idx\]),"
    puts $fp "            .clk(clk),"
    puts $fp "            .re(outscalar_re\[idx\]),"
    puts $fp "            .dout(outscalar_fifo32\[idx\])"
    puts $fp "        );"
    puts $fp ""
    puts $fp "        assign outscalar_re\[idx\] = scalar_re & (scalar_read_addr == (idx+C_MAX_INSCALARS));"
    puts $fp "    end"
    puts $fp "endgenerate"
    puts $fp ""
    puts $fp "    //read interface"
    puts $fp "    always @* begin"
    puts $fp "        if(scalar_read_addr >= C_MAX_INSCALARS)"
    puts $fp "            scalar_out_reg <= outscalar_fifo32\[scalar_read_addr-C_MAX_INSCALARS\];"
    puts $fp "        else"
    puts $fp "            scalar_out_reg <= 32'h00C0FFEE;"
    puts $fp "    end"
    puts $fp ""
    puts $fp "endmodule"

    close $fp
}

proc gen_infifo {num} {
    if {[file exists "hdl/in_fifo_args.v"]} {
	file delete -force "hdl/in_fifo_args.v"
    }
    set fp [open "hdl/in_fifo_args.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module in_fifo_args ("
    puts $fp "    input acc_clk,"
    puts $fp "    input dm_clk,"
    puts $fp "    //control interface"
    puts $fp "    input aresetn,"
    puts $fp "    input in_fifo_allow,"
    puts $fp "    output \[C_NUM_INPUT_FIFOs-1:0\] in_fifo_ready,"
    puts $fp "    output \[C_NUM_INPUT_FIFOs-1:0\] in_fifo_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_fifo_${idx}_tlast,"
	puts $fp "    input s_axis_fifo_${idx}_tvalid,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tkeep,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tstrb,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH-1:0\] s_axis_fifo_${idx}_tdata,"
	puts $fp "    output s_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_iarg_${idx}_empty_n,"
	puts $fp "    output \[C_INPUT_FIFO_${idx}_WIDTH-1:0\] ap_fifo_iarg_${idx}_dout,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_fifo_iarg_${idx}_read,"
	} else {
	    puts $fp "    input ap_fifo_iarg_${idx}_read"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "parameter C_NUM_INPUT_FIFOs = 0;"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_WIDTH = 8;     //width of input fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_DEPTH = 16;      //depth of FIFO in adapter for input fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for input fifo interface"
    }
    puts $fp ""
    puts $fp "    localparam C_MAX_INPUT_FIFOs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_INFIFO_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "C_INPUT_FIFO_${val}_WIDTH,"
	} else {
	    puts $fp "C_INPUT_FIFO_${val}_WIDTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "C_INPUT_FIFO_${val}_DEPTH,"
	} else {
	    puts $fp "C_INPUT_FIFO_${val}_DEPTH\};"
	}
    }
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_FIFOs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < $num} {incr idx} {
	set val [expr $num - $idx - 1]
	if {$idx < [expr $num - 1]} {
	    puts -nonewline $fp "C_INPUT_FIFO_${val}_DMWIDTH,"
	} else {
	    puts $fp "C_INPUT_FIFO_${val}_DMWIDTH\};"
	}
    }
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] dwconv_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] buf_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] read;"
    puts $fp "    wire \[C_NUM_INPUT_FIFOs-1:0\] empty;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout \[C_NUM_INPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INPUT_FIFOs > ${idx}) begin"
	puts $fp "            assign tlast\[${idx}\] = s_axis_fifo_${idx}_tlast;"
	puts $fp "            assign tvalid\[${idx}\] = s_axis_fifo_${idx}_tvalid;"
	puts $fp "            assign read\[${idx}\] = ap_fifo_iarg_${idx}_read;"
	puts $fp "            assign tkeep\[${idx}\]\[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] = s_axis_fifo_${idx}_tkeep;"
	puts $fp "            assign tstrb\[${idx}\]\[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] = s_axis_fifo_${idx}_tstrb;"
	puts $fp "            assign tdata\[${idx}\]\[C_INPUT_FIFO_${idx}_DMWIDTH-1:0\] = s_axis_fifo_${idx}_tdata;"
	puts $fp "            assign s_axis_fifo_${idx}_tready = tready\[${idx}\];"
	puts $fp "            assign ap_fifo_iarg_${idx}_empty_n = empty\[${idx}\];"
	puts $fp "            assign ap_fifo_iarg_${idx}_dout = dout\[${idx}\]\[C_INPUT_FIFO_${idx}_WIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_INPUT_FIFOs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(dm_clk),"
    puts $fp "                    .aresetn(aresetn),"
    puts $fp "                    .aclken(1),"
    puts $fp "                    .s_axis_tvalid(tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = tvalid\[idx\];"
    puts $fp "                assign tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            //always use fifo"
    puts $fp "            axis_fifo #("
    puts $fp "                .C_DATA_WIDTH(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis_fifo_i ("
    puts $fp "                .aresetn(aresetn),"
    puts $fp "                .inclk(dm_clk),"
    puts $fp "                .in_tdata(dwconv_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .in_tlast(dwconv_tlast\[idx\]),  "
    puts $fp "                .in_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                .in_tready(dwconv_tready\[idx\]),"
    puts $fp "                .outclk(acc_clk), "
    puts $fp "                .out_tdata(buf_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .out_tready(buf_tready\[idx\]),"
    puts $fp "                .out_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                .out_tlast(buf_tlast\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            axis2fifo #( "
    puts $fp "                .DATA_WIDTH(C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis2fifo_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(aresetn),"
    puts $fp "                .CTRL_ALLOW(in_fifo_allow),"
    puts $fp "                .CTRL_READY(in_fifo_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(in_fifo_finished\[idx\]),"
    puts $fp "                .AXIS_TLAST(buf_tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(buf_tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(buf_tdata\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(buf_tready\[idx\]),"
    puts $fp "                .FIFO_EMPTY(empty\[idx\]),"
    puts $fp "                .FIFO_DOUT(dout\[idx\]\[C_INFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .FIFO_READ(read\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_outfifo {num} {
    if {[file exists "hdl/out_fifo_args.v"]} {
	file delete -force "hdl/out_fifo_args.v"
    }
    set fp [open "hdl/out_fifo_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module out_fifo_args ("
    puts $fp "    input acc_clk,"
    puts $fp "    input dm_clk,"
    puts $fp "    //control interface"
    puts $fp "    input aresetn,"
    puts $fp "    input out_fifo_allow,"
    puts $fp "    output \[C_NUM_OUTPUT_FIFOs-1:0\] out_fifo_ready,"
    puts $fp "    output \[C_NUM_OUTPUT_FIFOs-1:0\] out_fifo_finished,"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output FIFO to AXI-Stream interface ${idx}"
	puts $fp "    output m_axis_fifo_${idx}_tlast,"
	puts $fp "    output m_axis_fifo_${idx}_tvalid,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tkeep,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tstrb,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH-1:0\] m_axis_fifo_${idx}_tdata,"
	puts $fp "    input m_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_oarg_${idx}_full_n,"
	puts $fp "    input \[C_OUTPUT_FIFO_${idx}_WIDTH-1:0\] ap_fifo_oarg_${idx}_din,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_fifo_oarg_${idx}_write,"
	} else {
	    puts $fp "    input ap_fifo_oarg_${idx}_write"
	}
    }
    puts $fp "    );"
    puts $fp ""
    puts $fp "parameter C_NUM_OUTPUT_FIFOs = 0;"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_WIDTH = 8;    //width of output fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_DEPTH = 16;     //depth of FIFO in adapter for output fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_DMWIDTH = 8;  //width of AXIS interface from DM to adapter for output fifo interface"
    }
    puts $fp ""
    puts $fp "    localparam C_MAX_OUTPUT_FIFOs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_OUTFIFO_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_FIFO_${val}_WIDTH,"
    }
    puts $fp "C_OUTPUT_FIFO_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_FIFO_${val}_DEPTH,"
    }
    puts $fp "C_OUTPUT_FIFO_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_FIFOs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_FIFO_${val}_DMWIDTH,"
    }
    puts $fp "C_OUTPUT_FIFO_0_DMWIDTH\};"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] buf_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf_tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tlast;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tvalid;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] dwconv_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tkeep \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv_tstrb \[C_NUM_OUTPUT_FIFOs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv_tdata \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] write;"
    puts $fp "    wire \[C_MAX_OUTPUT_FIFOs-1:0\] full;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din \[C_MAX_OUTPUT_FIFOs-1:0\];"
    puts $fp "        "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTPUT_FIFOs > ${idx}) begin"
	puts $fp "            assign dwconv_tready\[${idx}\] = m_axis_fifo_${idx}_tready;"
	puts $fp "            assign m_axis_fifo_${idx}_tlast = dwconv_tlast\[${idx}\];"
	puts $fp "            assign m_axis_fifo_${idx}_tvalid = dwconv_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_fifo_${idx}_tkeep = dwconv_tkeep\[${idx}\]\[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_fifo_${idx}_tstrb = dwconv_tstrb\[${idx}\]\[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_fifo_${idx}_tdata = dwconv_tdata\[${idx}\]\[C_OUTPUT_FIFO_${idx}_DMWIDTH-1:0\];"
	puts $fp "            assign ap_fifo_oarg_${idx}_full_n = full\[${idx}\];"
	puts $fp "            assign write\[${idx}\] = ap_fifo_oarg_${idx}_write;"
	puts $fp "            assign din\[${idx}\]\[C_OUTPUT_FIFO_${idx}_WIDTH-1:0\] = ap_fifo_oarg_${idx}_din;"
	puts $fp "            assign tkeep\[${idx}\] = {C_OUTPUT_FIFO_${idx}_WIDTH/8{1'b1}};"
	puts $fp "            assign tstrb\[${idx}\] = {C_OUTPUT_FIFO_${idx}_WIDTH/8{1'b1}};"
	puts $fp "        end"
    }
    puts $fp "    endgenerate    "
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_OUTPUT_FIFOs; idx=idx+1) begin: OUT_FIFO_GEN"
    puts $fp "            fifo2axis #( "
    puts $fp "                .DATA_WIDTH(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) fifo2axis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(aresetn),"
    puts $fp "                .CTRL_ALLOW(out_fifo_allow),"
    puts $fp "                .CTRL_READY(out_fifo_ready\[idx\]),"
    puts $fp "                .CTRL_FINISHED(out_fifo_finished\[idx\]),"
    puts $fp "                .AXIS_TLAST(tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(tready\[idx\]),"
    puts $fp "                .FIFO_FULL(full\[idx\]),"
    puts $fp "                .FIFO_DIN(din\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .FIFO_WRITE(write\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            //always use fifo"
    puts $fp "            axis_fifo #("
    puts $fp "                .C_DATA_WIDTH(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis_fifo_i ("
    puts $fp "                .aresetn(aresetn),"
    puts $fp "                .inclk(acc_clk),"
    puts $fp "                .in_tdata(tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .in_tlast(tlast\[idx\]),  "
    puts $fp "                .in_tvalid(tvalid\[idx\]),"
    puts $fp "                .in_tready(tready\[idx\]),"
    puts $fp "                .outclk(dm_clk), "
    puts $fp "                .out_tdata(buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .out_tready(buf_tready\[idx\]),"
    puts $fp "                .out_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                .out_tlast(buf_tlast\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_i ("
    puts $fp "                    .aclk(dm_clk),"
    puts $fp "                    .aresetn(aresetn),"
    puts $fp "                    .aclken(1),"
    puts $fp "                    .s_axis_tvalid(buf_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(buf_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(buf_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(dwconv_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(dwconv_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(dwconv_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no data width converter, wire the input signals straight through"
    puts $fp "                assign dwconv_tlast\[idx\] = buf_tlast\[idx\];"
    puts $fp "                assign dwconv_tvalid\[idx\] = buf_tvalid\[idx\];"
    puts $fp "                assign buf_tready\[idx\] = dwconv_tready\[idx\];   //output"
    puts $fp "                assign dwconv_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf_tdata\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = tstrb\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "                assign dwconv_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = tkeep\[idx\]\[C_OUTFIFO_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\];"
    puts $fp "            end"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"

    close $fp
}

proc gen_inbram {num} {
    if {[file exists "hdl/in_bram_args.v"]} {
	file delete -force "hdl/in_bram_args.v"
    }
    set fp [open "hdl/in_bram_args.v" "w"]
    
    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module in_bram_args ("
    puts $fp "    input acc_clk,"
    puts $fp "    input dm_clk,"
    puts $fp "    //control interface"
    puts $fp "    input aresetn,"
    puts $fp "    input acc_rstn,"
    puts $fp "    input in_bram_allow_in,"
    puts $fp "    input in_bram_allow_out,"
    puts $fp "    input acc_start,"
    puts $fp "    input acc_done,"
    puts $fp "    output \[C_NUM_INPUT_BRAMs-1:0\] in_bram_ready,"
    puts $fp "    output \[C_NUM_INPUT_BRAMs-1:0\] inout_bram_ready,"
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_bram_${idx}_tlast,"
	puts $fp "    input s_axis_bram_${idx}_tvalid,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tkeep,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tstrb,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH-1:0\] s_axis_bram_${idx}_tdata,"
	puts $fp "    output s_axis_bram_${idx}_tready,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din0,"
	puts $fp "    output \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_${idx}_we0,"
	puts $fp "    input ap_bram_${idx}_en0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr1,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din1,"
	puts $fp "    output \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout1,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_${idx}_we1,"
	puts $fp "    input ap_bram_${idx}_en1,"
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //in-out AXI-Stream output interface ${idx}"
	puts $fp "    output m_axis_bram_${idx}_tlast,"
	puts $fp "    output m_axis_bram_${idx}_tvalid,  "
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tkeep,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tstrb,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bram_${idx}_tdata,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input m_axis_bram_${idx}_tready,"
	} else {
	    puts $fp "    input m_axis_bram_${idx}_tready"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "parameter C_NUM_INPUT_BRAMs = 0; "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter C_INPUT_BRAM_${idx}_PORTS = 1;"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_WIDTH = 8;     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_DEPTH = 2;      //depth of BRAM in adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_DMWIDTH = 8;"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[0:0\] C_BRAM_${idx}_IS_INOUT = 0;"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_MB_DEPTH = 1;  //depth, number of copies of BRAM args"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_ADDR_WIDTH = 1;"
    }
    puts $fp ""
    puts $fp "    localparam C_MAX_INPUT_BRAMs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_INBRAM_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_WIDTH,"
    }
    puts $fp "C_INPUT_BRAM_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_DEPTH,"
    }
    puts $fp "C_INPUT_BRAM_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_DMWIDTH,"
    }
    puts $fp "C_INPUT_BRAM_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_INPUT_BRAMs-1:0\] C_INOUT_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_BRAM_${val}_IS_INOUT,"
    }
    puts $fp "C_BRAM_0_IS_INOUT\};"
    puts -nonewline $fp "    localparam \[C_MAX_INPUT_BRAMs*32-1:0\] C_ADDR_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_ADDR_WIDTH,"
    }
    puts $fp "C_INPUT_BRAM_0_ADDR_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_MB_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_MB_DEPTH,"
    }
    puts $fp "C_INPUT_BRAM_0_MB_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_INPUT_BRAMs*32)-1:0\] C_PORTS_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_INPUT_BRAM_${val}_PORTS,"
    }
    puts $fp "C_INPUT_BRAM_0_PORTS\};"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tkeep \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] tstrb \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\]   tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv0_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv0_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv1_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] dwconv1_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tkeep \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tstrb \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf0_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf0_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf1_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] buf1_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tlast;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] out_tdata \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] out_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr0 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr1 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din0 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din1 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout0 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout1 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we0 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we1 \[C_NUM_INPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] en0;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] en1;"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_INPUT_BRAMs > ${idx}) begin"
	puts $fp "            assign tlast\[${idx}\] = s_axis_bram_${idx}_tlast;"
	puts $fp "            assign tvalid\[${idx}\] = s_axis_bram_${idx}_tvalid;"
	puts $fp "            assign tkeep\[${idx}\]\[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] = s_axis_bram_${idx}_tkeep;"
	puts $fp "            assign tstrb\[${idx}\]\[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] = s_axis_bram_${idx}_tstrb;"
	puts $fp "            assign tdata\[${idx}\]\[C_INPUT_BRAM_${idx}_DMWIDTH-1:0\] = s_axis_bram_${idx}_tdata;"
	puts $fp "            assign s_axis_bram_${idx}_tready = tready\[${idx}\];"
	puts $fp "            "
	puts $fp "            assign addr0\[${idx}\]\[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr0;"
	puts $fp "            assign din0\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din0;"
	puts $fp "            assign ap_bram_${idx}_dout0 = dout0\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we0\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we0;"
	puts $fp "            assign en0\[${idx}\] = ap_bram_${idx}_en0;"
	puts $fp "            assign addr1\[${idx}\]\[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr1;"
	puts $fp "            assign din1\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din1;"
	puts $fp "            assign ap_bram_${idx}_dout1 = dout1\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we1\[${idx}\]\[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we1;"
	puts $fp "            assign en1\[${idx}\] = ap_bram_${idx}_en1;"
	puts $fp "            "
	puts $fp "            assign dwconv1_tready\[${idx}\] = m_axis_bram_${idx}_tready;"
	puts $fp "            assign m_axis_bram_${idx}_tlast = dwconv1_tlast\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tvalid = dwconv1_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tkeep = dwconv1_tkeep\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tstrb = dwconv1_tstrb\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tdata = dwconv1_tdata\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the axis2fifo modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_INPUT_BRAMs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                 axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_0i ("
    puts $fp "                    .aclk(dm_clk),"
    puts $fp "                    .aresetn(aresetn),"
    puts $fp "                    .aclken(1),"
    puts $fp "                    .s_axis_tvalid(tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb(tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tkeep(tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .s_axis_tlast(tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv0_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv0_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "//                    .m_axis_tstrb(),"
    puts $fp "//                    .m_axis_tkeep(),"
    puts $fp "                    .m_axis_tlast(dwconv0_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "                "
    puts $fp "                if( C_INOUT_BIT_ARRAY\[idx\] ) begin"
    puts $fp "                    axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                        .C_S_AXIS_TDATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                        .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                        .C_AXIS_TID_WIDTH(1),"
    puts $fp "                        .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                        .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                        .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                        .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                    ) data_width_conv_1i ("
    puts $fp "                        .aclk(dm_clk),"
    puts $fp "                        .aresetn(aresetn),"
    puts $fp "                        .aclken(1),"
    puts $fp "                        .s_axis_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                        .s_axis_tready(buf1_tready\[idx\]),"
    puts $fp "                        .s_axis_tdata(buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .s_axis_tstrb({C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                        .s_axis_tkeep({C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                        .s_axis_tlast(buf1_tlast\[idx\]),"
    puts $fp "                        .m_axis_tvalid(dwconv1_tvalid\[idx\]),"
    puts $fp "                        .m_axis_tready(dwconv1_tready\[idx\]),"
    puts $fp "                        .m_axis_tdata(dwconv1_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                        .m_axis_tstrb(dwconv1_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                        .m_axis_tkeep(dwconv1_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                        .m_axis_tlast(dwconv1_tlast\[idx\])"
    puts $fp "                    );"
    puts $fp "                end"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv0_tlast\[idx\] = tlast\[idx\];"
    puts $fp "                assign dwconv0_tvalid\[idx\] = tvalid\[idx\];"
    puts $fp "                assign tready\[idx\] = dwconv0_tready\[idx\];   //output"
    puts $fp "                assign dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp ""
    puts $fp "                assign dwconv1_tlast\[idx\] = buf1_tlast\[idx\];"
    puts $fp "                assign dwconv1_tvalid\[idx\] = buf1_tvalid\[idx\];"
    puts $fp "                assign buf1_tready\[idx\] = dwconv1_tready\[idx\];   //input"
    puts $fp "                assign dwconv1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv1_tkeep\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign dwconv1_tstrb\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            //always use fifo"
    puts $fp "            axis_fifo #("
    puts $fp "                .C_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_DATA_DEPTH(16)"
    puts $fp "            ) axis_fifo0_i ("
    puts $fp "                .aresetn(aresetn),"
    puts $fp "                .inclk(dm_clk), "
    puts $fp "                .in_tdata(dwconv0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .in_tlast(dwconv0_tlast\[idx\]),  "
    puts $fp "                .in_tvalid(dwconv0_tvalid\[idx\]),"
    puts $fp "                .in_tready(dwconv0_tready\[idx\]),"
    puts $fp "                .outclk(acc_clk), "
    puts $fp "                .out_tdata(buf0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .out_tready(buf0_tready\[idx\]),"
    puts $fp "                .out_tvalid(buf0_tvalid\[idx\]),"
    puts $fp "                .out_tlast(buf0_tlast\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            if( C_INOUT_BIT_ARRAY\[idx\] ) begin"
    puts $fp "                axis_fifo #("
    puts $fp "                    .C_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_DATA_DEPTH(16)"
    puts $fp "                ) axis_fifo1_i ("
    puts $fp "                    .aresetn(aresetn),"
    puts $fp "                    .inclk(acc_clk),"
    puts $fp "                    .in_tdata(out_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .in_tlast(out_tlast\[idx\]),  "
    puts $fp "                    .in_tvalid(out_tvalid\[idx\]),"
    puts $fp "                    .in_tready(out_tready\[idx\]),"
    puts $fp "                    .outclk(dm_clk), "
    puts $fp "                    .out_tdata(buf1_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .out_tready(buf1_tready\[idx\]),"
    puts $fp "                    .out_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                    .out_tlast(buf1_tlast\[idx\])"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            "
    puts $fp "            axis2bram #( "
    puts $fp "                .C_S_AXIS_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_M_AXIS_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_WIDTH(C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_IS_INOUT(C_INOUT_BIT_ARRAY\[idx:idx\]),"
    puts $fp "                .C_MB_DEPTH(C_MB_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_ADDR_WIDTH(C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_NUM_PORTS(C_PORTS_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) axis2bram_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_rstn),"
    puts $fp "                .CTRL_ACC_START(acc_start),"
    puts $fp "                .CTRL_ACC_DONE(acc_done),"
    puts $fp "                .CTRL_INREADY(in_bram_ready\[idx\]),"
    puts $fp "                .CTRL_OUTREADY(inout_bram_ready\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .S_AXIS_TLAST(buf0_tlast\[idx\]),"
    puts $fp "                .S_AXIS_TVALID(buf0_tvalid\[idx\]),"
    puts $fp "                .S_AXIS_TDATA(buf0_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .S_AXIS_TREADY(buf0_tready\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .M_AXIS_TLAST(out_tlast\[idx\]),"
    puts $fp "                .M_AXIS_TVALID(out_tvalid\[idx\]),"
    puts $fp "                .M_AXIS_TDATA(out_tdata\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .M_AXIS_TREADY(out_tready\[idx\]),"
    puts $fp "                //ACC BRAM IF-0"
    puts $fp "                .bram0_addr(addr0\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_din(din0\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_dout(dout0\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_we(we0\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram0_en(en0\[idx\]),"
    puts $fp "                //ACC BRAM IF-1"
    puts $fp "                .bram1_addr(addr1\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_din(din1\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_dout(dout1\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_we(we1\[idx\]\[C_INBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram1_en(en1\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_outbram {num} {
    if {[file exists "hdl/out_bram_args.v"]} {
	file delete -force "hdl/out_bram_args.v"
    }
    set fp [open "hdl/out_bram_args.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module out_bram_args ("
    puts $fp "    input acc_clk,"
    puts $fp "    input dm_clk,"
    puts $fp "    //control interface"
    puts $fp "    input aresetn,"
    puts $fp "    input acc_rstn,"
    puts $fp "    input outbram_allow,"
    puts $fp "    input acc_start,"
    puts $fp "    input acc_done,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ready,"
    puts $fp "    output \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_canstart,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth,"
    puts $fp "    input \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write,"
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //in-out AXI-Stream output interface ${idx}"
	puts $fp "    output m_axis_bram_${idx}_tlast,"
	puts $fp "    output m_axis_bram_${idx}_tvalid,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tkeep,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tstrb,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bram_${idx}_tdata,"
	puts $fp "    input m_axis_bram_${idx}_tready,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din0,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\]ap_bram_${idx}_we0,"
	puts $fp "    input ap_bram_${idx}_en0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_${idx}_addr1,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_din1,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_${idx}_dout1,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\]ap_bram_${idx}_we1,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_bram_${idx}_en1,"
	} else {
	    puts $fp "    input ap_bram_${idx}_en1"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "        "
    puts $fp "// function called clogb2 returns the ceil(log2(n))                     "
    puts $fp "function integer clogb2 (input integer bit_depth);              "
    puts $fp "begin                                                           "
    puts $fp "    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)                   "
    puts $fp "        bit_depth = bit_depth >> 1;                                 "
    puts $fp "    end                                                           "
    puts $fp "endfunction   "
    puts $fp "    "
    puts $fp "parameter C_QUEUE_DEPTH = 16;"
    puts $fp "parameter C_NUM_OUTPUT_BRAMs = 0; "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_WIDTH = 8;     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_DEPTH = 2;      //depth of FIFO in adapter for input bram interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_MB_DEPTH = 1; //depth of BRAM in adapter for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_ADDR_WIDTH = 1;"
    }
    puts $fp ""
    puts $fp "    localparam C_MAX_OUTPUT_BRAMs = ${num};"
    puts $fp "    localparam C_MAX_BIT_WIDTH = 1024;"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_OUTBRAM_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_BRAM_${val}_WIDTH,"
    }
    puts $fp "C_OUTPUT_BRAM_0_WIDTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_BRAM_${val}_DEPTH,"
    }
    puts $fp "C_OUTPUT_BRAM_0_DEPTH\};"
    puts -nonewline $fp "    localparam \[(C_MAX_OUTPUT_BRAMs*32)-1:0\] C_DMWIDTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_BRAM_${val}_DMWIDTH,"
    }
    puts $fp "C_OUTPUT_BRAM_0_DMWIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_OUTPUT_BRAMs*32-1:0\] C_ADDR_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_BRAM_${val}_ADDR_WIDTH,"
    }
    puts $fp "C_OUTPUT_BRAM_0_ADDR_WIDTH\};"
    puts -nonewline $fp "    localparam \[C_MAX_OUTPUT_BRAMs*32-1:0\] C_MB_DEPTH_BIT_ARRAY = \{"
    for {set idx 0} {$idx < [expr $num - 1]} {incr idx} {
	set val [expr $num - $idx - 1]
	puts -nonewline $fp "C_OUTPUT_BRAM_${val}_MB_DEPTH,"
    }
    puts $fp "C_OUTPUT_BRAM_0_MB_DEPTH\};"
    puts $fp "        "
    puts $fp "    wire \[31:0\] fifo_depth \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] fifo_depth_empty;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] fifo_depth_read;"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dwconv1_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] dwconv1_tready;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tkeep \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] dwconv1_tstrb \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    "
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] buf1_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] buf1_tready;"
    puts $fp ""
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tlast;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tvalid;"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] out_tdata \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] out_tready;"
    puts $fp "    "
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] addr1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] din1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH-1:0\] dout1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we0 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_MAX_BIT_WIDTH/8-1:0\] we1 \[C_NUM_OUTPUT_BRAMs-1:0\];"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] en0;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] en1;"
    puts $fp "    "
    puts $fp "    //assign inputs to buses, and buses to outputs"
    puts $fp "    generate"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        if(C_NUM_OUTPUT_BRAMs > ${idx}) begin"
	puts $fp "            assign addr0\[${idx}\]\[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr0;"
	puts $fp "            assign din0\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din0;"
	puts $fp "            assign ap_bram_${idx}_dout0 = dout0\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we0\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we0;"
	puts $fp "            assign en0\[${idx}\] = ap_bram_${idx}_en0;"
	puts $fp "            assign addr1\[${idx}\]\[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] = ap_bram_${idx}_addr1;"
	puts $fp "            assign din1\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] = ap_bram_${idx}_din1;"
	puts $fp "            assign ap_bram_${idx}_dout1 = dout1\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\];"
	puts $fp "            assign we1\[${idx}\]\[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\] = ap_bram_${idx}_we1;"
	puts $fp "            assign en1\[${idx}\] = ap_bram_${idx}_en1;"
	puts $fp "            "
	puts $fp "            assign dwconv1_tready\[${idx}\] = m_axis_bram_${idx}_tready;"
	puts $fp "            assign m_axis_bram_${idx}_tlast = dwconv1_tlast\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tvalid = dwconv1_tvalid\[${idx}\];"
	puts $fp "            assign m_axis_bram_${idx}_tkeep = dwconv1_tkeep\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tstrb = dwconv1_tstrb\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\];"
	puts $fp "            assign m_axis_bram_${idx}_tdata = dwconv1_tdata\[${idx}\]\[C_OUTPUT_BRAM_${idx}_DMWIDTH-1:0\];"
	puts $fp "        end"
    }
    puts $fp "    endgenerate"
    puts $fp "    "
    puts $fp "    //instantiate the bram2axis modules"
    puts $fp "    genvar idx;"
    puts $fp "    generate"
    puts $fp "        for(idx=0; idx<C_NUM_OUTPUT_BRAMs; idx=idx+1) begin: IN_FIFO_GEN"
    puts $fp "            //check if data width converter is needed"
    puts $fp "            if(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\] != C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]) begin"
    puts $fp "                axis_dwidth_converter_v1_1_9_axis_dwidth_converter #("
    puts $fp "                    .C_S_AXIS_TDATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_M_AXIS_TDATA_WIDTH(C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                    .C_AXIS_TID_WIDTH(1),"
    puts $fp "                    .C_AXIS_TDEST_WIDTH(1),"
    puts $fp "                    .C_S_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_M_AXIS_TUSER_WIDTH(1),"
    puts $fp "                    .C_AXIS_SIGNAL_SET(32'h1F)  //Enabled: TLAST, TKEEP, TSTRB, TDATA, TREADY"
    puts $fp "                ) data_width_conv_1i ("
    puts $fp "                    .aclk(dm_clk),"
    puts $fp "                    .aresetn(aresetn),"
    puts $fp "                    .aclken(1),"
    puts $fp "                    .s_axis_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                    .s_axis_tready(buf1_tready\[idx\]),"
    puts $fp "                    .s_axis_tdata(buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .s_axis_tstrb({C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                    .s_axis_tkeep({C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}}),"
    puts $fp "                    .s_axis_tlast(buf1_tlast\[idx\]),"
    puts $fp "//                    .s_axis_tid(),"
    puts $fp "//                    .s_axis_tdest(),"
    puts $fp "//                    .s_axis_tuser(),"
    puts $fp "                    .m_axis_tvalid(dwconv1_tvalid\[idx\]),"
    puts $fp "                    .m_axis_tready(dwconv1_tready\[idx\]),"
    puts $fp "                    .m_axis_tdata(dwconv1_tdata\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                    .m_axis_tstrb(dwconv1_tkeep\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tkeep(dwconv1_tstrb\[idx\]\[C_DMWIDTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                    .m_axis_tlast(dwconv1_tlast\[idx\])"
    puts $fp "//                    .m_axis_tid(),"
    puts $fp "//                    .m_axis_tdest(),"
    puts $fp "//                    .m_axis_tuser()"
    puts $fp "                );"
    puts $fp "            end"
    puts $fp "            else begin"
    puts $fp "                //if no buffering, wire the input signals straight through"
    puts $fp "                assign dwconv1_tlast\[idx\] = buf1_tlast\[idx\];"
    puts $fp "                assign dwconv1_tvalid\[idx\] = buf1_tvalid\[idx\];"
    puts $fp "                assign buf1_tready\[idx\] = dwconv1_tready\[idx\];   //input"
    puts $fp "                assign dwconv1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\] = buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\];"
    puts $fp "                assign dwconv1_tkeep\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "                assign dwconv1_tstrb\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\] = {C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8{1'b1}};"
    puts $fp "            end"
    puts $fp "                        "
    puts $fp "            axis_fifo #("
    puts $fp "                .C_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_DATA_DEPTH(16)"
    puts $fp "            ) axis_fifo1_i ("
    puts $fp "                .aresetn(aresetn),"
    puts $fp "                .inclk(acc_clk),"
    puts $fp "                .in_tdata(out_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .in_tlast(out_tlast\[idx\]),  "
    puts $fp "                .in_tvalid(out_tvalid\[idx\]),"
    puts $fp "                .in_tready(out_tready\[idx\]),"
    puts $fp "                .outclk(dm_clk), "
    puts $fp "                .out_tdata(buf1_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .out_tready(buf1_tready\[idx\]),"
    puts $fp "                .out_tvalid(buf1_tvalid\[idx\]),"
    puts $fp "                .out_tlast(buf1_tlast\[idx\])"
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            fifo #( "
    puts $fp "                .WIDTH(32),"
    puts $fp "                .DEPTH(C_QUEUE_DEPTH)"
    puts $fp "            ) depth_queue_i ("
    puts $fp "                .wr_clk(dm_clk),"
    puts $fp "                .din(outbram_depth\[(idx+1)*32-1:idx*32\]),"
    puts $fp "                .write(outbram_depth_write\[idx\]),"
    puts $fp "                .full(),"
    puts $fp "                .dout(fifo_depth\[idx\]),"
    puts $fp "                .read(fifo_depth_read\[idx\]),"
    puts $fp "                .empty(fifo_depth_empty\[idx\]),"
    puts $fp "                .rd_clk(acc_clk) "
    puts $fp "            );"
    puts $fp "            "
    puts $fp "            bram2axis #( "
    puts $fp "                .C_AXIS_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_DEPTH(C_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_DATA_WIDTH(C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_BRAM_ADDR_WIDTH(C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]),"
    puts $fp "                .C_MB_DEPTH(C_MB_DEPTH_BIT_ARRAY\[32*(idx+1)-1:32*idx\])"
    puts $fp "            ) bram2axis_i ("
    puts $fp "                .ACC_CLK(acc_clk),"
    puts $fp "                .ARESETN(acc_rstn),"
    puts $fp "                .CTRL_ACC_START(acc_start),"
    puts $fp "                .CTRL_ACC_DONE(acc_done),"
    puts $fp "                .CTRL_READY(outbram_ready\[idx\]),"
    puts $fp "                .CTRL_CANSTART(outbram_canstart\[idx\]),"
    puts $fp "                .DATA_DEPTH(fifo_depth\[idx\]),"
    puts $fp "                .DATA_DEPTH_READ(fifo_depth_read\[idx\]),"
    puts $fp "                .DATA_DEPTH_EMPTY(fifo_depth_empty\[idx\]),"
    puts $fp "                //.AXI Stream interface"
    puts $fp "                .AXIS_TLAST(out_tlast\[idx\]),"
    puts $fp "                .AXIS_TVALID(out_tvalid\[idx\]),"
    puts $fp "                .AXIS_TDATA(out_tdata\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .AXIS_TREADY(out_tready\[idx\]),"
    puts $fp "                //ACC BRAM IF-0"
    puts $fp "                .bram0_addr(addr0\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_din(din0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_dout(dout0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram0_we(we0\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram0_en(en0\[idx\]),"
    puts $fp "                //ACC BRAM IF-1"
    puts $fp "                .bram1_addr(addr1\[idx\]\[C_ADDR_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_din(din1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_dout(dout1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]-1:0\]),"
    puts $fp "                .bram1_we(we1\[idx\]\[C_OUTBRAM_BIT_ARRAY\[32*(idx+1)-1:32*idx\]/8-1:0\]),"
    puts $fp "                .bram1_en(en1\[idx\])"
    puts $fp "            );"
    puts $fp "        end"
    puts $fp "    endgenerate"
    puts $fp "endmodule"
    
    close $fp
}

proc gen_top {num} {
    if {[file exists "hdl/top.v"]} {
	file delete -force "hdl/top.v"
    }
    set fp [open "hdl/top.v" "w"]

    puts $fp "`timescale 1ns / 1ps"
    puts $fp ""
    puts $fp "module top ("
    puts $fp "    //axi lite interface"
    puts $fp "    input s_axi_aclk,"
    puts $fp "    input s_axi_aresetn,"
    puts $fp "    input \[31 : 0\] S_AXI_AWADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_AWPROT,"
    puts $fp "    input S_AXI_AWVALID,"
    puts $fp "    output S_AXI_AWREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_WDATA,"
    puts $fp "    input \[3 : 0\] S_AXI_WSTRB,"
    puts $fp "    input S_AXI_WVALID,"
    puts $fp "    output S_AXI_WREADY,"
    puts $fp "    output \[1 : 0\] S_AXI_BRESP,"
    puts $fp "    output S_AXI_BVALID,"
    puts $fp "    input S_AXI_BREADY,"
    puts $fp "    input \[31 : 0\] S_AXI_ARADDR,"
    puts $fp "    input \[2 : 0\] S_AXI_ARPROT,"
    puts $fp "    input S_AXI_ARVALID,"
    puts $fp "    output S_AXI_ARREADY,"
    puts $fp "    output \[31 : 0\] S_AXI_RDATA,"
    puts $fp "    output \[1 : 0\] S_AXI_RRESP,"
    puts $fp "    output S_AXI_RVALID,"
    puts $fp "    input S_AXI_RREADY,"
    puts $fp "    //acc clock"
    puts $fp "    input aclk,"
    puts $fp "    input resetn,"
    puts $fp "    //acc interface"
    puts $fp "    output aresetn,"
    puts $fp "    output ap_start,"
    puts $fp "    input ap_idle,"
    puts $fp "    input ap_done,"
    puts $fp "    input ap_ready,"
    puts $fp "    output ap_continue,"
    puts $fp "    output ap_clk,"
    puts $fp "    //-----------------------------------------------------"
    puts $fp "    //input scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    output \[C_INPUT_SCALAR_${idx}_WIDTH-1:0\] ap_iscalar_${idx}_dout,"
    }
    puts $fp "    //output scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input \[C_OUTPUT_SCALAR_${idx}_WIDTH-1:0\] ap_oscalar_${idx}_din,"
    }
    puts $fp "    //output scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    input ap_oscalar_${idx}_vld,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to FIFO interface ${idx}"
	puts $fp "    input s_axis_fifo_${idx}_tlast,"
	puts $fp "    input s_axis_fifo_${idx}_tvalid,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tkeep,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH/8-1:0\] s_axis_fifo_${idx}_tstrb,"
	puts $fp "    input \[C_INPUT_FIFO_${idx}_DMWIDTH-1:0\] s_axis_fifo_${idx}_tdata,"
	puts $fp "    output s_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_iarg_${idx}_empty_n,"
	puts $fp "    output \[C_INPUT_FIFO_${idx}_WIDTH-1:0\] ap_fifo_iarg_${idx}_dout,"
	puts $fp "    input ap_fifo_iarg_${idx}_read,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //output FIFO to AXI-Stream interface ${idx}"
	puts $fp "    output m_axis_fifo_${idx}_tlast,"
	puts $fp "    output m_axis_fifo_${idx}_tvalid,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tkeep,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH/8-1:0\] m_axis_fifo_${idx}_tstrb,"
	puts $fp "    output \[C_OUTPUT_FIFO_${idx}_DMWIDTH-1:0\] m_axis_fifo_${idx}_tdata,"
	puts $fp "    input m_axis_fifo_${idx}_tready,"
	puts $fp "    output ap_fifo_oarg_${idx}_full_n,"
	puts $fp "    input \[C_OUTPUT_FIFO_${idx}_WIDTH-1:0\] ap_fifo_oarg_${idx}_din,"
	puts $fp "    input ap_fifo_oarg_${idx}_write,"
    }
    puts $fp "    //-----------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //input AXI-Stream to BRAM interface ${idx}"
	puts $fp "    input s_axis_bram_${idx}_tlast,"
	puts $fp "    input s_axis_bram_${idx}_tvalid,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tkeep,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH/8-1:0\] s_axis_bram_${idx}_tstrb,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_DMWIDTH-1:0\] s_axis_bram_${idx}_tdata,"
	puts $fp "    output s_axis_bram_${idx}_tready,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_iarg_${idx}_addr0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_din0,"
	puts $fp "    output \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_dout0,"
	puts $fp "    input ap_bram_iarg_${idx}_clk0,"
	puts $fp "    input ap_bram_iarg_${idx}_rst0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_iarg_${idx}_we0,"
	puts $fp "    input ap_bram_iarg_${idx}_en0,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_iarg_${idx}_addr1,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_din1,"
	puts $fp "    output \[C_INPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_iarg_${idx}_dout1,"
	puts $fp "    input ap_bram_iarg_${idx}_clk1,"
	puts $fp "    input ap_bram_iarg_${idx}_rst1,"
	puts $fp "    input \[C_INPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_iarg_${idx}_we1,"
	puts $fp "    input ap_bram_iarg_${idx}_en1,"
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //in-out BRAM AXI-Stream output interface ${idx}"
	puts $fp "    output m_axis_bramio_${idx}_tlast,"
	puts $fp "    output m_axis_bramio_${idx}_tvalid,"
	puts $fp "    output \[C_INOUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tkeep,"
	puts $fp "    output \[C_INOUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bramio_${idx}_tstrb,"
	puts $fp "    output \[C_INOUT_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bramio_${idx}_tdata,"
	puts $fp "    input m_axis_bramio_${idx}_tready,"
    }
    puts $fp "    //-----------------------------------------------------------"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "    //out AXI-Stream output interface ${idx}"
	puts $fp "    output m_axis_bram_${idx}_tlast,"
	puts $fp "    output m_axis_bram_${idx}_tvalid,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tkeep,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH/8-1:0\] m_axis_bram_${idx}_tstrb,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_DMWIDTH-1:0\] m_axis_bram_${idx}_tdata,"
	puts $fp "    input m_axis_bram_${idx}_tready,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_oarg_${idx}_addr0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_din0,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_dout0,"
	puts $fp "    input ap_bram_oarg_${idx}_clk0,"
	puts $fp "    input ap_bram_oarg_${idx}_rst0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_oarg_${idx}_we0,"
	puts $fp "    input ap_bram_oarg_${idx}_en0,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_ADDR_WIDTH-1:0\] ap_bram_oarg_${idx}_addr1,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_din1,"
	puts $fp "    output \[C_OUTPUT_BRAM_${idx}_WIDTH-1:0\] ap_bram_oarg_${idx}_dout1,"
	puts $fp "    input ap_bram_oarg_${idx}_clk1,"
	puts $fp "    input ap_bram_oarg_${idx}_rst1,"
	puts $fp "    input \[C_OUTPUT_BRAM_${idx}_WIDTH/8-1:0\] ap_bram_oarg_${idx}_we1,"
	if {$idx < [expr $num - 1]} {
	    puts $fp "    input ap_bram_oarg_${idx}_en1,"
	} else {
	    puts $fp "    input ap_bram_oarg_${idx}_en1"
	}
    }
    puts $fp ");"
    puts $fp ""
    puts $fp "//adapter parameters"
    puts $fp "parameter C_ACC_RESET_POLARITY = 0;"
    puts $fp "parameter C_QUEUE_DEPTH = 16;"
    puts $fp ""
    puts $fp "//scalar parameters"
    puts $fp "parameter C_N_INPUT_SCALARS = 0;"
    puts $fp "parameter C_N_OUTPUT_SCALARS = 0;"
    puts $fp "parameter C_FIFO_DEPTH = 16;"
    puts $fp "parameter C_HAS_RETURN = 0;"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_SCALAR_${idx}_WIDTH = 1;"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\]  C_OUTPUT_SCALAR_${idx}_WIDTH = 1;"
    }
    puts $fp ""
    puts $fp "//fifo arg parameters"
    puts $fp "parameter C_NUM_INPUT_FIFOs = 0;                //number of input fifo interfaces on the accelerator"
    puts $fp "parameter C_NUM_OUTPUT_FIFOs = 0;               //number of output fifo interfaces on the accelerator"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_WIDTH = 8;     //width of input fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_DEPTH = 16;      //depth of FIFO in adapter for input fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_FIFO_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for input fifo interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_WIDTH = 8;    //width of output fifo interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_DEPTH = 16;     //depth of FIFO in adapter for output fifo interface (minimum value 1, required for clock conversion)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_FIFO_${idx}_DMWIDTH = 8;  //width of AXIS interface from DM to adapter for output fifo interface"
    }
    puts $fp ""
    puts $fp "//bram arg parameters"
    puts $fp "parameter C_NUM_INPUT_BRAMs = 0; "
    puts $fp "parameter C_NUM_OUTPUT_BRAMs = 0; "
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter C_INPUT_BRAM_${idx}_PORTS = 1;            //number of bram ports (dual-ported, partitioned)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_WIDTH = 8;     //width of input bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_DEPTH = 2;     //depth of BRAM in adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for input bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INOUT_BRAM_${idx}_DMWIDTH = 8;   //width of AXIS interface from DM to adapter for inout (output) bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[0:0\] C_BRAM_${idx}_IS_INOUT = 0;         //enables the input bram also for output"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_INPUT_BRAM_${idx}_MB_DEPTH = 1;  //depth, number of copies of BRAM args"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter C_OUTPUT_BRAM_${idx}_PORTS = 1;           //number of bram ports (dual-ported, partitioned)"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_WIDTH = 8;    //width of output bram interface on the accelerator"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_DEPTH = 2;    //depth of BRAM in adapter for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_DMWIDTH = 8;  //width of AXIS interface from adapter to DM for output bram interface"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter \[31:0\] C_OUTPUT_BRAM_${idx}_MB_DEPTH = 1; //depth of BRAM in adapter for output bram interface"
    }
    puts $fp ""
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter C_INPUT_BRAM_${idx}_ADDR_WIDTH = 1;"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "parameter C_OUTPUT_BRAM_${idx}_ADDR_WIDTH = 1;"
    }
    puts $fp ""
    puts $fp "    //scalar interface "
    puts $fp "    wire \[31:0\] scalar_write_addr;"
    puts $fp "    wire \[31:0\] scalar_read_addr;"
    puts $fp "    wire \[31:0\] scalar_din;"
    puts $fp "    wire scalar_we;"
    puts $fp "    wire scalar_re;"
    puts $fp "    wire \[31:0\] scalar_dout;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_next;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_fifo_empty;"
    puts $fp "    wire \[C_N_INPUT_SCALARS-1:0\] inscalar_fifo_full;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_fifo_empty;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_fifo_full;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_empty;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_dout;"
    puts $fp "    wire \[C_N_OUTPUT_SCALARS-1:0\] outscalar_null_read;"
    puts $fp "    "
    puts $fp "    //wire in bram control interface"
    puts $fp "    wire inbram_ctrl_allow;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] inbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs-1:0\] inoutbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_INPUT_BRAMs*32-1:0\] inbram_depth;"
    puts $fp "    "
    puts $fp "    //wire in fifo control interface"
    puts $fp "    wire infifo_ctrl_allow;"
    puts $fp "    "
    puts $fp "    //wire out bram control interface"
    puts $fp "    wire outbram_ctrl_allow;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_ready;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_ctrl_canstart;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs*32-1:0\] outbram_depth;"
    puts $fp "    wire \[C_NUM_OUTPUT_BRAMs-1:0\] outbram_depth_write;"
    puts $fp "    "
    puts $fp "    //wire out fifo control interface"
    puts $fp "    wire outfifo_ctrl_allow;"
    puts $fp ""
    puts $fp "    adapter #("
    puts $fp "        .C_ACC_RESET_POLARITY(C_ACC_RESET_POLARITY),"
    puts $fp "        .C_NUM_INPUT_SCALARS(C_N_INPUT_SCALARS),"
    puts $fp "        .C_NUM_OUTPUT_SCALARS(C_N_OUTPUT_SCALARS),"
    puts $fp "        .C_QUEUE_DEPTH(C_QUEUE_DEPTH),"
    puts $fp "        .C_NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    puts $fp "        .C_NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    puts $fp "        .C_NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    puts $fp "        .C_NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs)"
    puts $fp "    ) adapter_i ("
    puts $fp "        .S_AXI_ACLK(s_axi_aclk),"
    puts $fp "        .S_AXI_ARESETN(s_axi_aresetn),"
    puts $fp "        .S_AXI_AWADDR(S_AXI_AWADDR),"
    puts $fp "        .S_AXI_AWPROT(S_AXI_AWPROT),"
    puts $fp "        .S_AXI_AWVALID(S_AXI_AWVALID),"
    puts $fp "        .S_AXI_AWREADY(S_AXI_AWREADY),"
    puts $fp "        .S_AXI_WDATA(S_AXI_WDATA),"
    puts $fp "        .S_AXI_WSTRB(S_AXI_WSTRB),"
    puts $fp "        .S_AXI_WVALID(S_AXI_WVALID),"
    puts $fp "        .S_AXI_WREADY(S_AXI_WREADY),"
    puts $fp "        .S_AXI_BRESP(S_AXI_BRESP),"
    puts $fp "        .S_AXI_BVALID(S_AXI_BVALID),"
    puts $fp "        .S_AXI_BREADY(S_AXI_BREADY),"
    puts $fp "        .S_AXI_ARADDR(S_AXI_ARADDR),"
    puts $fp "        .S_AXI_ARPROT(S_AXI_ARPROT),"
    puts $fp "        .S_AXI_ARVALID(S_AXI_ARVALID),"
    puts $fp "        .S_AXI_ARREADY(S_AXI_ARREADY),"
    puts $fp "        .S_AXI_RDATA(S_AXI_RDATA),"
    puts $fp "        .S_AXI_RRESP(S_AXI_RRESP),"
    puts $fp "        .S_AXI_RVALID(S_AXI_RVALID),"
    puts $fp "        .S_AXI_RREADY(S_AXI_RREADY),"
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        .acc_rstn(resetn),"
    puts $fp "        .ap_rst(aresetn),"
    puts $fp "        .ap_start(ap_start),"
    puts $fp "        .ap_start_single(ap_start_single),"
    puts $fp "        .ap_idle(ap_idle),"
    puts $fp "        .ap_done(ap_done),"
    puts $fp "        .ap_ready(ap_ready),"
    puts $fp "        .ap_continue(ap_continue),"
    puts $fp "        .ap_clk(ap_clk),"
    puts $fp "        .scalar_write_addr(scalar_write_addr),"
    puts $fp "        .scalar_read_addr(scalar_read_addr),"
    puts $fp "        .scalar_din(scalar_din),"
    puts $fp "        .scalar_we(scalar_we),"
    puts $fp "        .scalar_re(scalar_re),"
    puts $fp "        .scalar_dout(scalar_dout),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_fifo_full(inscalar_fifo_full),"
    puts $fp "        .outscalar_fifo_empty(outscalar_fifo_empty),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .outscalar_null_empty(outscalar_null_empty),"
    puts $fp "        .outscalar_null_dout(outscalar_null_dout),"
    puts $fp "        .outscalar_null_read(outscalar_null_read),"
    puts $fp "        .inbram_ctrl_allow(inbram_ctrl_allow),"
    puts $fp "        .inbram_ctrl_ready(inbram_ctrl_ready),"
    puts $fp "        .inoutbram_ctrl_ready(inoutbram_ctrl_ready),"
    puts $fp "        .infifo_ctrl_allow(infifo_ctrl_allow),"
    puts $fp "        .outbram_ctrl_allow(outbram_ctrl_allow),"
    puts $fp "        .outbram_ctrl_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_ctrl_canstart(outbram_ctrl_canstart),"
    puts $fp "        .outbram_depth(outbram_depth),"
    puts $fp "        .outbram_depth_write(outbram_depth_write),"
    puts $fp "        .outfifo_ctrl_allow(outfifo_ctrl_allow)"
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    scalar #("
    puts $fp "        .C_NUM_INSCALARS(C_N_INPUT_SCALARS),"
    puts $fp "        .C_NUM_OUTSCALARS(C_N_OUTPUT_SCALARS),"
    puts $fp "        .C_FIFO_DEPTH(C_FIFO_DEPTH),"
    puts $fp "        .C_HAS_RETURN(C_HAS_RETURN),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INSCALAR_${idx}_BITS(C_INPUT_SCALAR_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .C_OUTSCALAR_${idx}_BITS(C_OUTPUT_SCALAR_${idx}_WIDTH),"
	} else {
	    puts $fp "        .C_OUTSCALAR_${idx}_BITS(C_OUTPUT_SCALAR_${idx}_WIDTH)"
	}
    }
    puts $fp "    ) scalar_i ("
    puts $fp "        .clk(s_axi_aclk),"
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        //control interface"
    puts $fp "        .scalar_read_addr(scalar_read_addr),"
    puts $fp "        .scalar_re(scalar_re),"
    puts $fp "        .scalar_dout(scalar_dout),"
    puts $fp "        .scalar_we(scalar_we),"
    puts $fp "        .scalar_write_addr(scalar_write_addr),"
    puts $fp "        .scalar_din(scalar_din),"
    puts $fp "        .outscalar_capture(ap_done),"
    puts $fp "        .inscalar_next(inscalar_next),"
    puts $fp "        .inscalar_fifo_empty(inscalar_fifo_empty),"
    puts $fp "        .inscalar_fifo_full(inscalar_fifo_full),"
    puts $fp "        .outscalar_fifo_empty(outscalar_fifo_empty),"
    puts $fp "        .outscalar_fifo_full(outscalar_fifo_full),"
    puts $fp "        .outscalar_null_empty(outscalar_null_empty),"
    puts $fp "        .outscalar_null_dout(outscalar_null_dout),"
    puts $fp "        .outscalar_null_read(outscalar_null_read),"
    puts $fp "        //.scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .inscalar${idx}(ap_iscalar_${idx}_dout),"
    }
    puts $fp "        //.scalar ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .outscalar${idx}(ap_oscalar_${idx}_din),"
    }
    puts $fp "        //.scalar valid ports"
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .outscalar${idx}_vld(ap_oscalar_${idx}_vld),"
	} else {
	    puts $fp "        .outscalar${idx}_vld(ap_oscalar_${idx}_vld)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    in_fifo_args #("
    puts $fp "        .C_NUM_INPUT_FIFOs(C_NUM_INPUT_FIFOs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_FIFO_${idx}_WIDTH(C_INPUT_FIFO_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_FIFO_${idx}_DEPTH(C_INPUT_FIFO_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .C_INPUT_FIFO_${idx}_DMWIDTH(C_INPUT_FIFO_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .C_INPUT_FIFO_${idx}_DMWIDTH(C_INPUT_FIFO_${idx}_DMWIDTH)"
	}
    }
    puts $fp "    ) in_fifo_args_i ("
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .aresetn(s_axi_aresetn),"
    puts $fp "        .in_fifo_allow(infifo_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_fifo_${idx}_tlast(s_axis_fifo_${idx}_tlast),"
	puts $fp "        .s_axis_fifo_${idx}_tvalid(s_axis_fifo_${idx}_tvalid),"
	puts $fp "        .s_axis_fifo_${idx}_tkeep(s_axis_fifo_${idx}_tkeep),"
	puts $fp "        .s_axis_fifo_${idx}_tstrb(s_axis_fifo_${idx}_tstrb),"
	puts $fp "        .s_axis_fifo_${idx}_tdata(s_axis_fifo_${idx}_tdata),"
	puts $fp "        .s_axis_fifo_${idx}_tready(s_axis_fifo_${idx}_tready),"
	puts $fp "        .ap_fifo_iarg_${idx}_empty_n(ap_fifo_iarg_${idx}_empty_n),"
	puts $fp "        .ap_fifo_iarg_${idx}_dout(ap_fifo_iarg_${idx}_dout),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_fifo_iarg_${idx}_read(ap_fifo_iarg_${idx}_read),"
	} else {
	    puts $fp "        .ap_fifo_iarg_${idx}_read(ap_fifo_iarg_${idx}_read)"
	}
    }
    puts $fp "    );"
    puts $fp "        "
    puts $fp "    out_fifo_args #("
    puts $fp "        .C_NUM_OUTPUT_FIFOs(C_NUM_OUTPUT_FIFOs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_FIFO_${idx}_WIDTH(C_OUTPUT_FIFO_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_FIFO_${idx}_DEPTH(C_OUTPUT_FIFO_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .C_OUTPUT_FIFO_${idx}_DMWIDTH(C_OUTPUT_FIFO_${idx}_DMWIDTH),"
	} else {
	    puts $fp "        .C_OUTPUT_FIFO_${idx}_DMWIDTH(C_OUTPUT_FIFO_${idx}_DMWIDTH)"
	}
    } 
    puts $fp "    ) out_fifo_args_i ("
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .aresetn(s_axi_aresetn),"
    puts $fp "        .out_fifo_allow(outfifo_ctrl_allow),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_fifo_${idx}_tlast(m_axis_fifo_${idx}_tlast),"
	puts $fp "        .m_axis_fifo_${idx}_tvalid(m_axis_fifo_${idx}_tvalid),"
	puts $fp "        .m_axis_fifo_${idx}_tkeep(m_axis_fifo_${idx}_tkeep),"
	puts $fp "        .m_axis_fifo_${idx}_tstrb(m_axis_fifo_${idx}_tstrb),"
	puts $fp "        .m_axis_fifo_${idx}_tdata(m_axis_fifo_${idx}_tdata),"
	puts $fp "        .m_axis_fifo_${idx}_tready(m_axis_fifo_${idx}_tready),"
	puts $fp "        .ap_fifo_oarg_${idx}_full_n(ap_fifo_oarg_${idx}_full_n),"
	puts $fp "        .ap_fifo_oarg_${idx}_din(ap_fifo_oarg_${idx}_din),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_fifo_oarg_${idx}_write(ap_fifo_oarg_${idx}_write),"
	} else {
	    puts $fp "        .ap_fifo_oarg_${idx}_write(ap_fifo_oarg_${idx}_write)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    in_bram_args #("
    puts $fp "        .C_NUM_INPUT_BRAMs(C_NUM_INPUT_BRAMs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_BRAM_${idx}_PORTS(C_INPUT_BRAM_${idx}_PORTS),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_BRAM_${idx}_WIDTH(C_INPUT_BRAM_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_BRAM_${idx}_DEPTH(C_INPUT_BRAM_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_BRAM_${idx}_DMWIDTH(C_INPUT_BRAM_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_BRAM_${idx}_DMWIDTH(C_INOUT_BRAM_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_BRAM_${idx}_IS_INOUT(C_BRAM_${idx}_IS_INOUT),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_INPUT_BRAM_${idx}_MB_DEPTH(C_INPUT_BRAM_${idx}_MB_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .C_INPUT_BRAM_${idx}_ADDR_WIDTH(C_INPUT_BRAM_${idx}_ADDR_WIDTH),"
	} else {
	    puts $fp "        .C_INPUT_BRAM_${idx}_ADDR_WIDTH(C_INPUT_BRAM_${idx}_ADDR_WIDTH)"
	}
    }
    puts $fp "    ) in_bram_args_i ("
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .aresetn(s_axi_aresetn),"
    puts $fp "        .acc_rstn(resetn),"
    puts $fp "        .in_bram_allow_in(inbram_ctrl_allow),"
    puts $fp "        .in_bram_allow_out(outbram_ctrl_allow),"
    puts $fp "        .acc_start(ap_start_single),"
    puts $fp "        .acc_done(ap_done),"
    puts $fp "        .in_bram_ready(inbram_ctrl_ready),"
    puts $fp "        .inout_bram_ready(inoutbram_ctrl_ready),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .s_axis_bram_${idx}_tlast(s_axis_bram_${idx}_tlast),"
	puts $fp "        .s_axis_bram_${idx}_tvalid(s_axis_bram_${idx}_tvalid),"
	puts $fp "        .s_axis_bram_${idx}_tkeep(s_axis_bram_${idx}_tkeep),"
	puts $fp "        .s_axis_bram_${idx}_tstrb(s_axis_bram_${idx}_tstrb),"
	puts $fp "        .s_axis_bram_${idx}_tdata(s_axis_bram_${idx}_tdata),"
	puts $fp "        .s_axis_bram_${idx}_tready(s_axis_bram_${idx}_tready),"
	puts $fp "        .ap_bram_${idx}_addr0(ap_bram_iarg_${idx}_addr0),"
	puts $fp "        .ap_bram_${idx}_din0(ap_bram_iarg_${idx}_din0),"
	puts $fp "        .ap_bram_${idx}_dout0(ap_bram_iarg_${idx}_dout0),"
	puts $fp "        .ap_bram_${idx}_we0(ap_bram_iarg_${idx}_we0),"
	puts $fp "        .ap_bram_${idx}_en0(ap_bram_iarg_${idx}_en0),"
	puts $fp "        .ap_bram_${idx}_addr1(ap_bram_iarg_${idx}_addr1),"
	puts $fp "        .ap_bram_${idx}_din1(ap_bram_iarg_${idx}_din1),"
	puts $fp "        .ap_bram_${idx}_dout1(ap_bram_iarg_${idx}_dout1),"
	puts $fp "        .ap_bram_${idx}_we1(ap_bram_iarg_${idx}_we1),"
	puts $fp "        .ap_bram_${idx}_en1(ap_bram_iarg_${idx}_en1),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_bram_${idx}_tlast(m_axis_bramio_${idx}_tlast),"
	puts $fp "        .m_axis_bram_${idx}_tvalid(m_axis_bramio_${idx}_tvalid),"
	puts $fp "        .m_axis_bram_${idx}_tkeep(m_axis_bramio_${idx}_tkeep),"
	puts $fp "        .m_axis_bram_${idx}_tstrb(m_axis_bramio_${idx}_tstrb),"
	puts $fp "        .m_axis_bram_${idx}_tdata(m_axis_bramio_${idx}_tdata),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .m_axis_bram_${idx}_tready(m_axis_bramio_${idx}_tready),"
	} else {
	    puts $fp "        .m_axis_bram_${idx}_tready(m_axis_bramio_${idx}_tready)"
	}
    }
    puts $fp "    );"
    puts $fp "    "
    puts $fp "    out_bram_args #("
    puts $fp "        .C_QUEUE_DEPTH(C_QUEUE_DEPTH),"
    puts $fp "        .C_NUM_OUTPUT_BRAMs(C_NUM_OUTPUT_BRAMs),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_BRAM_${idx}_WIDTH(C_OUTPUT_BRAM_${idx}_WIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_BRAM_${idx}_DEPTH(C_OUTPUT_BRAM_${idx}_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_BRAM_${idx}_DMWIDTH(C_OUTPUT_BRAM_${idx}_DMWIDTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .C_OUTPUT_BRAM_${idx}_MB_DEPTH(C_OUTPUT_BRAM_${idx}_MB_DEPTH),"
    }
    for {set idx 0} {$idx < $num} {incr idx} {
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .C_OUTPUT_BRAM_${idx}_ADDR_WIDTH(C_OUTPUT_BRAM_${idx}_ADDR_WIDTH),"
	} else {
	    puts $fp "        .C_OUTPUT_BRAM_${idx}_ADDR_WIDTH(C_OUTPUT_BRAM_${idx}_ADDR_WIDTH)"
	}
    }
    puts $fp "    ) out_bram_args_i ("
    puts $fp "        .acc_clk(aclk),"
    puts $fp "        .dm_clk(s_axi_aclk),"
    puts $fp "        .aresetn(s_axi_aresetn),"
    puts $fp "        .acc_rstn(resetn),"
    puts $fp "        .outbram_allow(outbram_ctrl_allow),"
    puts $fp "        .acc_start(ap_start_single),"
    puts $fp "        .acc_done(ap_done),"
    puts $fp "        .outbram_ready(outbram_ctrl_ready),"
    puts $fp "        .outbram_canstart(outbram_ctrl_canstart),"
    puts $fp "        .outbram_depth(outbram_depth),"
    puts $fp "        .outbram_depth_write(outbram_depth_write),"
    for {set idx 0} {$idx < $num} {incr idx} {
	puts $fp "        .m_axis_bram_${idx}_tlast(m_axis_bram_${idx}_tlast),"
	puts $fp "        .m_axis_bram_${idx}_tvalid(m_axis_bram_${idx}_tvalid),"
	puts $fp "        .m_axis_bram_${idx}_tkeep(m_axis_bram_${idx}_tkeep),"
	puts $fp "        .m_axis_bram_${idx}_tstrb(m_axis_bram_${idx}_tstrb),"
	puts $fp "        .m_axis_bram_${idx}_tdata(m_axis_bram_${idx}_tdata),"
	puts $fp "        .m_axis_bram_${idx}_tready(m_axis_bram_${idx}_tready),"
	puts $fp "        .ap_bram_${idx}_addr0(ap_bram_oarg_${idx}_addr0),"
	puts $fp "        .ap_bram_${idx}_din0(ap_bram_oarg_${idx}_din0),"
	puts $fp "        .ap_bram_${idx}_dout0(ap_bram_oarg_${idx}_dout0),"
	puts $fp "        .ap_bram_${idx}_we0(ap_bram_oarg_${idx}_we0),"
	puts $fp "        .ap_bram_${idx}_en0(ap_bram_oarg_${idx}_en0),"
	puts $fp "        .ap_bram_${idx}_addr1(ap_bram_oarg_${idx}_addr1),"
	puts $fp "        .ap_bram_${idx}_din1(ap_bram_oarg_${idx}_din1),"
	puts $fp "        .ap_bram_${idx}_dout1(ap_bram_oarg_${idx}_dout1),"
	puts $fp "        .ap_bram_${idx}_we1(ap_bram_oarg_${idx}_we1),"
	if {$idx < [expr $num - 1]} {
	    puts $fp "        .ap_bram_${idx}_en1(ap_bram_oarg_${idx}_en1),"
	} else {
	    puts $fp "        .ap_bram_${idx}_en1(ap_bram_oarg_${idx}_en1)"
	}
    }
    puts $fp "    );"
    puts $fp ""
    puts $fp "endmodule"

    close $fp
}
